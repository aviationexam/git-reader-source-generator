using GitReader.Structures;
using H.Generators;
using H.Generators.Extensions;
using Microsoft.CodeAnalysis;
using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace GitReader.SourceGenerator;

[Generator]
public class GitInfoGenerator : IIncrementalGenerator
{
    public const string Id = "GI";

    public void Initialize(
        IncrementalGeneratorInitializationContext context
    ) => context.AnalyzerConfigOptionsProvider
        .Select(static (x, _) => new GitInfoConfiguration(
            x.GetRequiredGlobalOption("GitInfo_RootDirectory"),
            x.GetRequiredGlobalOption("GitInfo_Namespace"),
            x.GetGlobalOption("GitInfo_CommitAbbreviatedLength") is { } commitAbbreviatedString
            && int.TryParse(commitAbbreviatedString, out var commitAbbreviatedLength)
                ? commitAbbreviatedLength
                : 9,
            // ReSharper disable once SimplifyConditionalTernaryExpression
            x.GetGlobalOption("GitInfo_UseCache") is { } useCacheString
            && bool.TryParse(useCacheString, out var useCache)
                ? useCache
                : true
        ))
        .SelectAndReportExceptions(GetSourceCode, context, Id)
        .AddSource(context);

    private record GitInfoConfiguration(
        string RootDirectory,
        string TargetNamespace,
        int CommitAbbreviatedLength,
        bool UseCache
    );

    private static FileWithName GetSourceCode(
        GitInfoConfiguration configuration,
        CancellationToken cancellationToken
    ) => GetSourceCodeAsync(configuration, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();

    private static GitInfo? _gitInfoCache;

    private static async Task<FileWithName> GetSourceCodeAsync(
        GitInfoConfiguration configuration,
        CancellationToken cancellationToken
    )
    {
        const string fileName = "GitInfo.g.cs";

        using var repository = await Repository.Factory.OpenStructureAsync(
            configuration.RootDirectory,
            cancellationToken
        );

        if (repository.Head is { } head)
        {
            if (_gitInfoCache is { } gitInfoCache && gitInfoCache.CommitHash == head.Head.ToString())
            {
                return new FileWithName(
                    fileName,
                    GetFileContent(gitInfoCache)
                );
            }

            var refLogs = await repository.GetHeadReflogsAsync(cancellationToken);

            var refLog = refLogs[0];

            var commitHash = refLog.Commit.ToString();
            var commitAbbreviatedHash = commitHash;

            if (commitAbbreviatedHash.Length > configuration.CommitAbbreviatedLength)
            {
                commitAbbreviatedHash = commitHash[..configuration.CommitAbbreviatedLength];
            }

            var tags = repository.Tags;

            string? tagName = null;
            Tag? tag = null;
            Version? tagVersion = null;

            for (var i = 0; i < refLogs.Length; i++)
            {
                var refLogI = refLogs[i];

                var regLogHasTags = tags
                    .Where(x => refLogI.Commit.HashCode.SequenceEqual(x.Value.ObjectHash.HashCode))
                    .Select(x => (TagName: x.Key, Tag: x.Value, Version: new Version(x.Value.Name)))
                    .ToList();

                if (regLogHasTags.Count == 0)
                {
                    continue;
                }

                if (regLogHasTags.Count == 1)
                {
                    (tagName, tag, tagVersion) = regLogHasTags.Single();

                    continue;
                }

                (tagName, tag, tagVersion) = regLogHasTags.OrderBy(x => x.Version).Single();
            }

            gitInfoCache = new GitInfo(
                configuration.TargetNamespace,
                head.Name,
                commitAbbreviatedHash,
                commitHash,
                refLog.Committer.Date,
                tagName,
                tag,
                tagVersion
            );

            if (configuration.UseCache)
            {
                _gitInfoCache = gitInfoCache;
            }

            return new FileWithName(
                fileName,
                GetFileContent(gitInfoCache)
            );
        }

        return new FileWithName(
            fileName,
            GetFileContent(new GitInfo(
                configuration.TargetNamespace,
                "Unknown",
                "123456789",
                "Unknown",
                DateTimeOffset.MinValue,
                TagName: null,
                Tag: null,
                TagVersion: null
            ))
        );
    }

    private static string GetFileContent(
        GitInfo gitInfo
    ) => $$"""
           // <auto-generated />
           #nullable enable

           using System;

           namespace {{gitInfo.Namespace}};

           public static class GitInfo
           {
               public const string Branch = "{{gitInfo.Branch}}";

               public const string CommitAbbreviatedHash = "{{gitInfo.CommitAbbreviatedHash}}";

               public const string CommitHash = "{{gitInfo.CommitHash}}";

               public static DateTimeOffset CommitDate = new DateTimeOffset({{gitInfo.CommitDate.Ticks}}, new TimeSpan({{gitInfo.CommitDate.Offset.Ticks}}));

               public static string? TagName = {{(gitInfo.TagName is null ? "null" : $"\"{gitInfo.TagName}\"")}};

               public static string? Tag = {{(gitInfo.Tag is null ? "null" : $"\"{gitInfo.Tag.Name}\"")}};

               public static int? TagMajor = {{(gitInfo.TagVersion is null || gitInfo.TagVersion.Major is -1 ? "null" : $"{gitInfo.TagVersion.Major}")}};

               public static int? TagMinor = {{(gitInfo.TagVersion is null || gitInfo.TagVersion.Minor is -1 ? "null" : $"{gitInfo.TagVersion.Minor}")}};

               public static int? TagBuild = {{(gitInfo.TagVersion is null || gitInfo.TagVersion.Build is -1 ? "null" : $"{gitInfo.TagVersion.Build}")}};

               public static int? TagRevision = {{(gitInfo.TagVersion is null || gitInfo.TagVersion.Revision is -1 ? "null" : $"{gitInfo.TagVersion.Revision}")}};
           }

           #nullable restore
           """;

    private record GitInfo(
        string Namespace,
        string Branch,
        string CommitAbbreviatedHash,
        string CommitHash,
        DateTimeOffset CommitDate,
        string? TagName,
        Tag? Tag,
        Version? TagVersion
    );
}
